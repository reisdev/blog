---
title: "Como criar um App para iOS em ViewCode"
datePublished: Fri Jul 21 2023 14:43:41 GMT+0000 (Coordinated Universal Time)
cuid: clkcoyt92000e09l41g93a218
slug: como-criar-um-app-para-ios-em-viewcode
canonical: https://dev.to/reisdev/como-criar-um-app-ios-em-viewcode-3l8j
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1689948445925/838ead9f-3c5a-419a-9e71-f716a4d1c4a0.jpeg
tags: swift, ios, beginners

---

## 1\. Contexto

ViewCode √© um termo usado para descrever a constru√ß√£o de interfaces de usu√°rio utilizando apenas c√≥digo. Inicialmente as telas eram criadas usando Storyboard/XIB, atrav√©s da interface gr√°fica do pr√≥prio Xcode. Por√©m, existiam algunss problemas:

* Acesso limitado a propriedades dos elementos
    
* Conflitos de modifica√ß√£o de arquivos (*merge hell*)
    
* Quando o app crescia muito, os arquivos ficavam pesados e causavam lentid√£o no Xcode (Storyboard)
    

Ent√£o, foi se criando um novo padr√£o, apelidado de `ViewCode`. Neste artigo, veremos brevemente como ele funciona e como criar um app do zero baseado nesse formato.

## 2\. Criando o app

O primeiro passo, obviamente, √© criar um app. Para criar este tutorial estou usando a vers√£o 14.3.1 do Xcode. Caso voc√™ esteja usando uma vers√£o diferente, alguns detalhes podem mudar.

Primeiramente, abrimos o Xcode e clicamos em `Create a new Xcode Project`:

![Captura de tela da tela inicial do Xcode, com a lista de a√ß√µes poss√≠veis e os projetos recentes](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gc00t73yt74seovgi4la.png align="center")

Ap√≥s isso, o Xcode ir√° abrir uma janela para sele√ß√£o do tipo de aplicativo a ser criado:

![Captura de tela da etapa de cria√ß√£o de um novo projeto no Xcode, exibindo as poss√≠veis op√ß√µes para cada plataforma](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/w8fcx0ubmke7q5v18veg.png align="center")

Para este tutorial, iremos escolher a plataforma `iOS` e a op√ß√£o `App`, e ent√£o clicar em `Next`:

![Captura de tela do Xcode na etapa de cria√ß√£o de projeto com a aba iOS e a op√ß√£o App selecionadas](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/j80ahg9ct46zpk72q39b.png align="center")

A pr√≥xima etapa consiste em nomear o projeto e escolher algumas configura√ß√µes b√°sicas, como nome do app, time, *Bundle identifier*, tipo de interface(UI) e linguagem. Tamb√©m √© poss√≠vel optar por usar `CoreData` sincronizado com a nuvem e incluir testes. Para este tutorial, o mais importante √© selecionar modificar as seguintes op√ß√µes:

* `Interface ‚Üí Storyboard`
    
* `Language ‚Üí Swift`
    

Assim, garantimos que nosso app estar√° configurado para usar a linguagem Swift(e n√£o Obj-C) e, por padr√£o, a interface ser√° criada com Storyboard(e n√£o SwiftUI).

![Captura de tela do Xcode na etapa de escolha de op√ß√µes para o novo projeto](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pc3au7fgxxrujae4shc3.png align="center")

Ap√≥s clicar em `Next`, o Xcode ir√° apresentar uma tela para escolher onde deseja salvar os arquivos do seu projeto.

![Captura de tela do Xcode exibindo o Finder para selecionar onde deseja salvar o novo projeto](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/2chpq3ikt5z48fu6c50h.png align="center")

Bast selecionar a pasta desejada e clicar no bot√£o `Create`. Feito isso, seu projeto estar√° criado e ser√° aberto pelo Xcode:

![Captura de tela do Xcode com o projeto ExampleApp criado aberto](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/f0qlvjpimmn62rh25a83.png align="center")

Agora que j√° temos um novo projeto, vamos para o pr√≥ximo passo: remover o Storyboard.

## 3\. Removendo o Storyboard

Nas propriedades do projeto `ExampleApp`, que j√° s√£o abertas logo ap√≥s a cria√ß√£o do mesmo, precisamos acessar a aba `Info` Caso voc√™, por acaso, feche essa janela, √© poss√≠vel acess√°-la novamente clicando duas vezes no item do projeto na barra lateral esquerda:

![Captura de tela do Xcode destacando item do projeto e a aba Info](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/kpqg4cczot1u1f1ws3ad.png align="center")

Na aba `Info`, na se√ß√£o `Custom iOS Target Properties`, encontre os itens `Main Storyboard file base name` e `Application Scene Manifest ‚Üí Scene Configuration ‚Üí Default Configuration > Storyboard name` e remova-os da lista, usando o √≠cone de menos pr√≥ximo ao nome do item ou selecionando-o e apertando a tecla delete/backspace:

![Captura de tela destacando o item Main Storyboard file base name e uma seta indicando o bot√£o de menos, para remover o item](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/c8v9os7ft19fkj1a512x.png align="center")

![Captura de tela destacando o item Storyboard name e com uma seta indicando o bot√£o de menos, para remover o item](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/loc4p02oi7xd44sloqbk.png align="center")

Ap√≥s excluir estes itens, podemos remover o arquivo `Main.storyboard` do nosso projeto, j√° que ele n√£o ser√° mais necess√°rio. Para isso, basta encontr√°-lo na barra lateral esquerda e apag√°-lo, usando o atalho `Cmd+Delete` ou pelo menu de atalhos, como abaixo:

![Captura de tela do Xcode com o arquivo Main.storyboard selecionado, com a caixa de op√ß√µes aberta e o item Delete em destaque](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/kv73gb2yyts4dbuyzwzy.png align="center")

Agora que nosso projeto n√£o possui mais um arquivo Storyboard, podemos come√ßar a configurar nosso app para ser constru√≠do usando ViewCode.

## 4\. ViewCode

### 4.1. Configurando o ViewCode

J√° que n√£o temos mais um Storyboard para apresentar nossa tela, precisamos definir um novo respons√°vel por essa apresenta√ß√£o. Para isso, vamos acessar o arquivo `SceneDelegate` e fazer algumas modifica√ß√µes no m√©todo `scene`. Inicialmente, ele j√° vem com alguns coment√°rios, mas, pra encurtar o trecho de c√≥digo, eles foram removidos nesse exemplo. Inicialmente, esse √© o conte√∫do do m√©todo:

```swift
class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?

    func scene(_ scene: UIScene,
               willConnectTo session: UISceneSession,
               options connectionOptions: UIScene.ConnectionOptions) {
        
        guard let _ = (scene as? UIWindowScene) else {
            return 
        }

    // [...] Outros m√©todos do SceneDelegate
}
```

Primeiro, iremos obter a `scene` que nosso m√©todo recebe e tentar convert√™-la em uma `UIWindowScene`. Isso j√° est√° escrito no m√©todo, por√©m o valor da convers√£o est√° sendo descartado, por conta do `let _ = [...]`. Para isso, basta nomearmos a atribui√ß√£o para obter o valor:

```swift
guard let windowScene = (scene as? UIWindowScene) else {
    return 
}
```

Precisamos fazer essa convers√£o e obter o valor pois iremos us√°-lo cria√ß√£o da nossa `UIWindow` usada no `SceneDelegate`:

```swift
self.window = UIWindow(windowScene: windowScene)
```

Com uma window definida, o pr√≥ximo passo √© instanciar uma `UINavigationController` para ser apresentada, para que nosso app j√° seja constru√≠do com suporte para navega√ß√£o.

O projeto `ExampleApp` j√° foi criado com uma `ViewController` de exemplo, e ela ser√° a tela inicial(`rootViewController`) da navega√ß√£o do nosso app:

```swift
let navigationController = UINavigationController(rootViewController: ViewController())
```

Agora que j√° temos uma `UINavigationController`, podemos defini-la como sendo a raiz(`rootViewController`) das nossas telas na `window`. Em seguida, fazemos com ela seja definida como a principal e apresentada na tela atrav√©s do m√©todo `makeKeyAndVisible`:

```swift
self.window?.rootViewController = navigationController
self.window?.makeKeyAndVisible()
```

Ap√≥s cada passo citado acima, teremos o seguinte c√≥digo:

```swift
class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        
        guard let windowScene = (scene as? UIWindowScene) else {
            return
        }
        
        self.window = UIWindow(windowScene: windowScene)
        
        let navigationController = UINavigationController(rootViewController: ViewController())
        
        self.window?.rootViewController = navigationController
        self.window?.makeKeyAndVisible()
    }

    // [...] Outros m√©todos do SceneDelegate
}
```

A pr√≥xima etapa consiste em criar um padr√£o para constru√ß√£o das views atrav√©s de um protocolo.

### 4.2. Criando um protocolo ViewCode

Uma padroniza√ß√£o muito interessante √© criar um protocolo que ir√° definir o formato que uma `UIView` constru√≠da em ViewCode deve ter. Dessa forma, todas as views ter√£o um mesmo padr√£o de constru√ß√£o e ficar√° mais f√°cil de encontrar informa√ß√µes importantes.

A seguir, uma sugest√£o de protocolo que possui o b√°sico necess√°rio para manter a constru√ß√£o de uma view bem organizada:

```swift
// Arquivo ViewCode.swift
protocol ViewCode {
    func addSubviews()
    func setupConstraints()
    func setupStyle()
}

extension ViewCode {
    func setup() {
        addSubviews()
        setupConstraints()
        setupStyle()
    }
}
```

Uma breve explica√ß√£o de cada m√©todo definido acima:

* `addSubviews()`: Adiciona as views como subviews e define a hierarquia entre elas
    
* `setupConstraints()`: Define as constraints a serem usadas para posicionar os elementos na view
    
* `setupStyle()`: Define os estilos da view, como cor, bordas e etc.
    
* `setup()`: Executa os tr√™s m√©todos anteriores como parte do processo padr√£o de inicializa√ß√£o de uma view
    

OBS: Criamos o m√©todo `setup` em uma `extension` do protocolo porque n√£o √© poss√≠vel criar implementa√ß√µes de m√©todos diretamente no protocolo. Mas, fazendo isso, conseguimos resumir o setup em uma √∫nica chamada de m√©todo, `setup()`. No pr√≥ximo passo veremos isso na pr√°tica.

Com nosso protocolo pronto, podemos criar uma view que conforme com ele e entender melhor como essa estrutura funciona.

### 4.3. Criando uma View com ViewCode

Como exemplo, iremos criar uma view para a nossa `ViewController` que tenha um texto e um bot√£o. Para isso, iremos precisar dos elementos `UILabel` e `UIButton`, contidos no framework `UIKit`.

Primeiramente, vamos um arquivo `View.swift` com a nossa classe `View`, que herda as caracter√≠sticas de uma `UIView`:

```swift
// Arquivo View.swift

// Importamos o UIKit
import UIKit

class View: UIView {
    init() {
        // Chamamos um m√©todo da UIView para inicializa√ß√£o
        super.init(frame: .zero)
    }

    // O m√©todo a seguir √© obrigat√≥rio na classe UIView
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}
```

Agora que temos uma `View`, podemos criar as views que ser√£o exibidas dentro dela. Como citado anteriormente, um texto e um bot√£o:

```swift
// Arquivo View.swift

// Importamos o UIKit
import UIKit

class View: UIView {
    
    private lazy var label: UILabel = {
        let label = UILabel()
        label.translatesAutoresizingMaskIntoConstraints = false
        return label
    }()

    private lazy var button: UIButton = {
        let button = UIButton()
        button.translatesAutoresizingMaskIntoConstraints = false
        button.setTitleColor(.blue, for: .normal)
        return button
    }()

    init() {
        // Chamamos um m√©todo da UIView para inicializa√ß√£o
        super.init(frame: .zero)
    }

    // O m√©todo a seguir √© obrigat√≥rio na classe UIView
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    func setup(labelText: String, buttonTitle: String) {
        label.text = labelText
        button.setTitle(buttonTitle, for: .normal)
    }
}
```

Talvez o trecho de c√≥digo acima tenha embaralhado um pouco sua mente com tantos conceitos diferentes e talvez desconhecidos. Abaixo, algumas respostas pra perguntas que provavelmente tenham surgido:

---

* Por qu√™ usar o modificador de acesso `private`?
    

Para evitar que a view seja modificada. Seguindo o princ√≠pio de encapsulamento, expomos apenas o que for estritamente necess√°rio, evitando que propriedades das nossas views sejam modificadas indevidamente. Para permitir que a view seja configurada, podemos criar um m√©todo `setup` que tenha como par√¢metros as informa√ß√µes necess√°rias.

* Por qu√™ usar `lazy`?
    

O termo *lazy*, do ingl√™s, descreve nossa view como "pregui√ßosa". E √© literalmente isso que ela √©. Usando essa palavra-chave definimos que o valor da nossa propriedade `label`, por exemplo, s√≥ ser√° definido na primeira vez que ela for acessada. E, ap√≥s a defini√ß√£o, esse valor n√£o poder√° ser alterado. Em que contexto isso √© √∫til? Quando temos renderiza√ß√£o condicional. Se uma view s√≥ √© adicionada caso uma condi√ß√£o seja atendida, evitamos que ela ocupe espa√ßo na mem√≥ria desnecessariamente.

* O que √© `label: UILabel= { /* ... */ }()`
    

O trecho acima √© chamado de *self-executing closure*. √â similar √† fun√ß√µes an√¥nimas em outras linguagens. Nesse caso, √© como se declar√°ssemos uma fun√ß√£o e ela fosse chamada imediatamente. Em Swift, significa criar uma *closure* e cham√°-la logo em seguida.

* Para que serve `translatesAutoresizingMaskIntoConstraints`?
    

Essa propriedade √© definida como `false` para permitir que as constraints que iremos definir n√£o entrem em conflito com constraints que s√£o geradas automaticamente pelo sistema. Assim, podemos definir nossas pr√≥prias constraints e posicionar os elementos como desejado.

* Por qu√™ o m√©todo `setup(labelText:,buttonTitle:)`?
    

Para permitir configurarmos as informa√ß√µes da nossa `View` sem a necessidade de expor cada uma das suas subviews. Dessa forma, limitamos a personaliza√ß√£o a apenas o texto do label e o t√≠tulo do `button`.

---

Os conceitos acima seguem as pr√°ticas mais recomendadas para cria√ß√£o de views usando ViewCode. Agora que est√£o todos esclarecidos, podemos seguir para o pr√≥ximo passo: fazer com que nossa view conforme com o protocolo `ViewCode`.

```swift
extension View: ViewCode {
    func addSubviews() {
        addSubview(label)
        addSubview(button)
    }
    
    func setupConstraints() {
        NSLayoutConstraint.activate([
            label.centerXAnchor.constraint(equalTo: centerXAnchor),
            label.centerYAnchor.constraint(equalTo: centerYAnchor),
 
            button.topAnchor.constraint(equalTo: label.bottomAnchor, constant: 8),
            button.centerXAnchor.constraint(equalTo: centerXAnchor)
        ])
    }

    func setupStyle() {
        backgroundColor = .white
    }
}
```

No trecho acima, usamos os m√©todos definidos no protocolo `ViewCode` para:

* Adicionar as views `label` e `button` √† nossa `View`
    
* Posicionar o `label` centralizado horizontalmente(`centerXAnchor`) e verticalmente(`centerYAnchor`) na `View`
    
* Posicionar o `button` centralizado horizontalmente(`centerXAnchor`) e, na vertical, a um espa√ßamento de `8` a partir da parte inferior(`bottomAnchor`) do nosso `label`
    
* Definir a cor de fundo(`backgroundColor`) da `View` como branca(`.white`)
    

Agora, precisamos apenas chamar o setup da `View` no `init`:

```swift
// Arquivo View.swift

// Importamos o UIKit
import UIKit

class View: UIView {
    
    private lazy var label: UILabel = {
        let label = UILabel()
        label.translatesAutoresizingMaskIntoConstraints = false
        return label
    }()

    private lazy var button: UIButton = {
        let button = UIButton()
        button.translatesAutoresizingMaskIntoConstraints = false
        button.setTitleColor(.blue, for: .normal)
        return button
    }()

    init() {
        // Chamamos um m√©todo da UIView para inicializa√ß√£o
        super.init(frame: .zero)
        // Chamamos o setup da nossa view
        setup()
    }

    // O m√©todo a seguir √© obrigat√≥rio na classe UIView
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    func setup(labelText: String, buttonTitle: String) {
        label.text = labelText
        button.setTitle(buttonTitle, for: .normal)
    }
}

extension View: ViewCode {
    func addSubviews() {
        addSubview(label)
        addSubview(button)
    }
    
    func setupConstraints() {
        NSLayoutConstraint.activate([
            label.centerXAnchor.constraint(equalTo: centerXAnchor),
            label.centerYAnchor.constraint(equalTo: centerYAnchor),
 
            button.topAnchor.constraint(equalTo: label.bottomAnchor, constant: 8),
            button.centerXAnchor.constraint(equalTo: centerXAnchor)
        ])
    }

    func setupStyle() {
        backgroundColor = .white
    }
}
```

Ap√≥s construir nossa `View`, podemos us√°-la na nossa `ViewController` para ser exibida.

### 4.4. Usando a View na ViewController

Agora, retornamos para a nossa `ViewController` criada anteriormente e podemos usar a `View` para ser exibida na tela:

```swift
// Arquivo ViewController.swift
class ViewController: UIViewController {

    private lazy var myView: View = {
        return View()
    }()

    // M√©todo do ciclo de vida que carrega a view
    override func loadView() {
        super.loadView()
        
        self.view = myView
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()

        // Configuramos a View usando o m√©todo setup
        myView.setup(labelText: "Ol√°, mundo!", buttonTitle: "Testar")
    }
}
```

Esse foi o √∫ltimo passo para conseguirmos exibir a nossa `View` criada utilizando o padr√£o `ViewCode`. Se voc√™ executar sua aplica√ß√£o, ver√° o seguinte resultado:

![Captura de tela do simulador do iPhone 14 Pro com uma tela com fundo branco. Ao centro, um bot√£o com os dizeres "Ol√° mundo!" e um bot√£o escrito "Testar"](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/z8j6wx6shxhirj180qzt.png align="center")

Pronto, agora temos uma tela constru√≠da utilizando ViewCode. Por√©m, falta um √∫ltimo detalhe: criamos um bot√£o, mas sem nenhuma intera√ß√£o. Nosso pr√≥ximo passo ser√° criar essa intera√ß√£o.

### 4.5. Adicionando uma a√ß√£o ao bot√£o

Primeiramente, vamos criar um `Delegate` para nossa View, que √© o padr√£o adotado dentro do pr√≥prio UIKit quando precisamos "encaminhar" uma a√ß√£o/informa√ß√£o para fora de uma View, "delegando" a responsabilidade de lidar com ela. Iremos cham√°-lo de `ViewDelegate`:

```swift
protocol ViewDelegate: AnyObject {
    func didTapButton()
}
```

Algo estranho apareceu nesse trecho, n√©? Por qu√™ nosso protocolo conforma com o protocolo `AnyObject`? Para permitir que nosso delegate seja uma refer√™ncia do tipo `weak`, que s√≥ objetos podem ter, e evitando assim *retain cycles*. Esse √© um detalhe mais complexo e que n√£o caberia nesse artigo(que j√° est√° extenso), mas √© importante saber a motiva√ß√£o.

Agora, precisamos criar uma propriedade `delegate` na nossa `View` e um m√©todo para lidar com a a√ß√£o do nosso bot√£o:

```swift
protocol ViewDelegate: AnyObject {
    func didTapButton()
}

class View: UIView {
    // ...

    private lazy var button: UIButton = {
        let button = UIButton()
        button.translatesAutoresizingMaskIntoConstraints = false
        button.setTitleColor(.blue, for: .normal)
        button.addTarget(self, selector: #selector(didTapButton), for: .touchUpInside)
        return button
    }()

    weak var delegate: ViewDelegate?

    // ...    

    @objc 
    private func didTapButton() {
        delegate?.didTapButton()
    }
}
```

Explicando melhor o trecho acima:

* `delegate`: √â uma propriedade com refer√™ncia fraca(`weak`) e opcional(`?`) usada para que a `View` consiga notificar quem a esteja usando que uma a√ß√£o aconteceu, como o toque no bot√£o
    
* `@objc`: Essa propriedade do m√©todo `didTapButton` permite que ele interaja com c√≥digo em Objective-C, que √© o caso de boa parte do UIKit. No caso, ele √© necess√°rio para que o m√©todo possa ser usado no `#selector` para adicion√°-lo √† intera√ß√£o do bot√£o
    
* `addTarget(_ target:, action:, for:`): √â o m√©todo usado para adicionar a a√ß√£o ao bot√£o. O primeiro par√¢metro, `target`, recebe a refer√™ncia da classe onde est√° o m√©todo, o segundo recebe a a√ß√£o em si, e para isso usamos o `#selector()`. Por fim, no `for:` informamos que o m√©todo ser√° chamado para o toque dentro do bot√£o, por isso `.touchUpInside`.
    

Feito isso, j√° temos toda a configura√ß√£o do lado da `View` para lidar com uma a√ß√£o. Agora, falta designarmos para a ViewController a responsabilidade de processar a a√ß√£o:

```swift
class ViewController: UIViewController {

    private lazy var myView: View = {
        let view = View()
        // Atribuimos a ViewController como delegate
        view.delegate = self
        return view
    }()

    // ...
}

extension ViewController: ViewDelegate {
    func didTapButton() {
       // Nossa a√ß√£o ir√° atualizar a View
       myView.setup(labelText: "Sucesso!", buttonTitle: "Testar novamente")
    }
}
```

No trecho acima, modificamos a nossa `ViewController` para ser atribu√≠da como `delegate` da `View` e para conformar com o protocolo `ViewDelegate` para processar a a√ß√£o de toque no bot√£o. Ao tocar no bot√£o, nossa `ViewController` atualiza a `View` com novas informa√ß√µes, ficando assim:

![Captura de tela do simulador do iPhone 14 Pro com os dizeres "Sucesso!" e "Tentar novamente"](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/c7ifr86274nh61sx9vml.png align="center")

## 5\. Conclus√£o

Passando por cada etapa desse tutorial, voc√™ ter√° conhecimento suficiente para come√ßar seus estudos sobre cria√ß√£o de telas seguindo o padr√£o ViewCode.

O c√≥digo completo desse artigo pode ser encontrado neste reposit√≥rio:

%[https://github.com/reisdev/viewcode-example-ios] 

Ficou com alguma d√∫vida? Deixe nos coment√°rios ou me procure em alguma das minhas redes, que voc√™ encontra [aqui](reisdev.com.br)

At√© o pr√≥ximo artigo üëãüèΩ.

Capa por [UX Store](https://unsplash.com/@uxstore?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) no [Unsplash](https://unsplash.com/photos/jJT2r2n7lYA?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)